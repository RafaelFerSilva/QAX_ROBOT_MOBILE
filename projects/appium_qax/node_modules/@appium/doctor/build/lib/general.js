"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OptionalMjpegConsumerCommandCheck = exports.OptionalFfmpegCommandCheck = exports.NodeVersionCheck = exports.NodeBinaryCheck = exports.AppiumHomeCheck = void 0;
const utils_1 = require("./utils");
const teen_process_1 = require("teen_process");
const doctor_1 = require("./doctor");
const node_detector_1 = __importDefault(require("./node-detector"));
const support_1 = require("@appium/support");
const os_1 = require("os");
require("@colors/colors");
/**
 * @type {import('./factory').DoctorCheckList}
 */
let checks = [];
class AppiumHomeCheck extends doctor_1.DoctorCheck {
    /**
     *
     * @returns {UtilsResult}
     */
    async diagnose() {
        return (0, utils_1.ok)(`APPIUM_HOME is ${await support_1.env.resolveAppiumHome()}`);
    }
    fix() { }
}
exports.AppiumHomeCheck = AppiumHomeCheck;
checks.push(new AppiumHomeCheck());
// Node Binary
class NodeBinaryCheck extends doctor_1.DoctorCheck {
    async diagnose() {
        let nodePath = await node_detector_1.default.detect();
        return nodePath
            ? (0, utils_1.ok)(`The Node.js binary was found at: ${nodePath}`)
            : (0, utils_1.nok)('The Node.js binary was NOT found!');
    }
    fix() {
        return `Manually setup ${'Node.js'.bold}.`;
    }
}
exports.NodeBinaryCheck = NodeBinaryCheck;
checks.push(new NodeBinaryCheck());
const REQUIRED_NODE_VERSION = '14.0.0';
// Node version
class NodeVersionCheck extends doctor_1.DoctorCheck {
    async diagnose() {
        let nodePath = await node_detector_1.default.detect();
        if (!nodePath) {
            return (0, utils_1.nok)('Node is not installed, so no version to check!');
        }
        let { stdout } = await (0, teen_process_1.exec)(nodePath, ['--version']);
        let versionString = stdout.replace('v', '').trim();
        try {
            return support_1.util.compareVersions(REQUIRED_NODE_VERSION, '<=', versionString)
                ? (0, utils_1.ok)(`Node version is ${versionString}`)
                : (0, utils_1.nok)(`Node version should be at least ${REQUIRED_NODE_VERSION}!`);
        }
        catch {
            return (0, utils_1.nok)(`Unable to find node version (version = '${versionString}')`);
        }
    }
    fix() {
        return `Manually upgrade ${'Node.js'.bold}.`;
    }
}
exports.NodeVersionCheck = NodeVersionCheck;
checks.push(new NodeVersionCheck());
class OptionalFfmpegCommandCheck extends doctor_1.DoctorCheck {
    /**
     *
     * @returns {Promise<UtilsResult>}
     */
    async diagnose() {
        const ffmpegPath = await (0, utils_1.resolveExecutablePath)('ffmpeg');
        return ffmpegPath
            ? (0, utils_1.okOptional)(`ffmpeg is installed at: ${ffmpegPath}. ${(await (0, teen_process_1.exec)('ffmpeg', ['-version'])).stdout.split('\n')[0]}`)
            : (0, utils_1.nokOptional)('ffmpeg cannot be found');
    }
    /**
     *
     * @returns {string}
     */
    fix() {
        return `${'ffmpeg'.bold} is needed to record screen features. Please read https://www.ffmpeg.org/ to install it`;
    }
}
exports.OptionalFfmpegCommandCheck = OptionalFfmpegCommandCheck;
checks.push(new OptionalFfmpegCommandCheck());
class OptionalMjpegConsumerCommandCheck extends doctor_1.DoctorCheck {
    async diagnose() {
        const packageName = 'mjpeg-consumer';
        const packageInfo = await (0, utils_1.getNpmPackageInfo)(packageName);
        if (packageInfo) {
            return (0, utils_1.okOptional)(`${packageName} is installed at: ${packageInfo.path}. Installed version is: ${packageInfo.version}`);
        }
        return (0, utils_1.nokOptional)(`${packageName} cannot be found.`);
    }
    // eslint-disable-next-line require-await
    async fix() {
        return `${'mjpeg-consumer'.bold} module is required to use MJPEG-over-HTTP features. Please install it with 'npm i -g mjpeg-consumer'.`;
    }
}
exports.OptionalMjpegConsumerCommandCheck = OptionalMjpegConsumerCommandCheck;
checks.push(new OptionalMjpegConsumerCommandCheck());
exports.default = checks;
/**
 * @typedef {import('./utils').UtilsResult} UtilsResult
 */
//# sourceMappingURL=general.js.map