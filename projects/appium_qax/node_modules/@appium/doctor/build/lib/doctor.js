"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixSkippedError = exports.DoctorCheck = exports.Doctor = void 0;
require("@colors/colors");
const lodash_1 = __importDefault(require("lodash"));
const logger_1 = __importDefault(require("./logger"));
const support_1 = require("@appium/support");
const { version } = support_1.fs.readPackageJsonFrom(__dirname);
class FixSkippedError extends Error {
}
exports.FixSkippedError = FixSkippedError;
/**
 * Create interface for other Doctors
 */
class DoctorCheck {
    /**
     * @param {DoctorOpts} opts
     */
    constructor(opts = {}) {
        this.autofix = !!opts.autofix;
    }
    /**
     * Every doctor diagnose the symptoms
     * @throws {Error}
     */
    diagnose() {
        throw new Error('Not Implemented!');
    }
    /**
     * Every doctor suggest the solutions to fix the sickness
     * @throws {Error}
     */
    fix() {
        // return string for manual fixes.
        throw new Error('Not Implemented!');
    }
}
exports.DoctorCheck = DoctorCheck;
class Doctor {
    constructor() {
        /**
         * All the sub check goes here after register
         * @type {DoctorCheck[]}
         */
        this.checks = [];
        this.checkOptionals = [];
        this.toFix = [];
        this.toFixOptionals = [];
    }
    /**
     * Register all the sub check and combine them together
     * @param {DoctorCheck[] | DoctorCheck} checks
     */
    register(checks) {
        checks = Array.isArray(checks) ? checks : [checks];
        this.checks = this.checks.concat(checks);
    }
    /**
     * The doctor shows the report
     */
    async diagnose() {
        logger_1.default.info(`### Diagnostic for ${'necessary'.green} dependencies starting ###`);
        this.toFix = [];
        for (const check of this.checks) {
            const res = await check.diagnose();
            if (res.optional) {
                this.checkOptionals.push(check);
                continue;
            }
            await this.diagnosticResultMessage(res, this.toFix, check);
        }
        logger_1.default.info(`### Diagnostic for necessary dependencies completed, ${await this.fixMessage(this.toFix.length)}. ###`);
        logger_1.default.info('');
        logger_1.default.info(`### Diagnostic for ${'optional'.yellow} dependencies starting ###`);
        this.toFixOptionals = [];
        for (const checkOptional of this.checkOptionals) {
            await this.diagnosticResultMessage(await checkOptional.diagnose(), this.toFixOptionals, checkOptional);
        }
        logger_1.default.info(`### Diagnostic for optional dependencies completed, ${await this.fixMessage(this.toFixOptionals.length, true)}. ###`);
        logger_1.default.info('');
    }
    async reportManualFixes(fix, fixOptioal) {
        const manualFixes = lodash_1.default.filter(fix, (f) => !f?.check?.autofix);
        const manualFixesOptional = lodash_1.default.filter(fixOptioal, (f) => !f?.check?.autofix);
        if (manualFixes.length > 0) {
            logger_1.default.info('### Manual Fixes Needed ###');
            logger_1.default.info('The configuration cannot be automatically fixed, please do the following first:');
            // for manual fixes, the fix method always return a string
            const fixMessages = [];
            for (const f of manualFixes) {
                fixMessages.push(await f.check.fix());
            }
            for (const m of lodash_1.default.uniq(fixMessages)) {
                logger_1.default.warn(` \u279C ${m}`);
            }
            logger_1.default.info('');
        }
        if (manualFixesOptional.length > 0) {
            logger_1.default.info('### Optional Manual Fixes ###');
            logger_1.default.info('The configuration can install optionally. Please do the following manually:');
            // for manual fixes, the fix method always return a string
            const fixMessages = [];
            for (const f of manualFixesOptional) {
                fixMessages.push(await f.check.fix());
            }
            for (const m of lodash_1.default.uniq(fixMessages)) {
                logger_1.default.warn(` \u279C ${m}`);
            }
            logger_1.default.info('');
        }
        if (manualFixes.length > 0 || manualFixesOptional.length > 0) {
            logger_1.default.info('###');
            logger_1.default.info('');
            logger_1.default.info('Bye! Run appium-doctor again when all manual fixes have been applied!');
            logger_1.default.info('');
            return true;
        }
        return false;
    }
    async runAutoFix(f) {
        logger_1.default.info(`### Fixing: ${f.error} ###`);
        try {
            await f.check.fix();
        }
        catch (err) {
            if (err instanceof FixSkippedError) {
                logger_1.default.info(`### Skipped fix ###`);
                return;
            }
            else {
                logger_1.default.warn(`${err}`.replace(/\n$/g, ''));
                logger_1.default.info(`### Fix did not succeed ###`);
                return;
            }
        }
        logger_1.default.info('Checking if this was fixed:');
        let res = await f.check.diagnose();
        if (res.ok) {
            f.fixed = true;
            logger_1.default.info(` ${'\u2714'.green} ${res.message}`);
            logger_1.default.info(`### Fix was successfully applied ###`);
        }
        else {
            logger_1.default.info(` ${'\u2716'.red} ${res.message}`);
            logger_1.default.info(`### Fix was applied but issue remains ###`);
        }
    }
    async runAutoFixes() {
        let autoFixes = lodash_1.default.filter(this.toFix, (f) => f?.check?.autofix);
        for (let f of autoFixes) {
            await this.runAutoFix(f);
            logger_1.default.info('');
        }
        if (lodash_1.default.find(autoFixes, (f) => !f.fixed)) {
            // a few issues remain.
            logger_1.default.info('Bye! A few issues remain, fix manually and/or rerun appium-doctor!');
        }
        else {
            // nothing left to fix.
            logger_1.default.info('Bye! All issues have been fixed!');
        }
        logger_1.default.info('');
    }
    async run() {
        logger_1.default.info(`Appium Doctor v.${version}`);
        await this.diagnose();
        if (await this.reportSuccess(this.toFix.length, this.toFixOptionals.length)) {
            return;
        }
        if (await this.reportManualFixes(this.toFix, this.toFixOptionals)) {
            return;
        }
        await this.runAutoFixes();
    }
    //// generating messages
    // eslint-disable-next-line require-await
    async diagnosticResultMessage(result, toFixList, check) {
        if (result.ok) {
            logger_1.default.info(` ${'\u2714'.green} ${result.message}`);
        }
        else {
            const errorMessage = result.optional
                ? ` ${'\u2716'.yellow} ${result.message}`
                : ` ${'\u2716'.red} ${result.message}`;
            logger_1.default.warn(errorMessage);
            toFixList.push({
                error: errorMessage,
                check,
            });
        }
    }
    // eslint-disable-next-line require-await
    async fixMessage(length, optional = false) {
        let message;
        switch (length) {
            case 0:
                message = 'no fix';
                break;
            case 1:
                message = 'one fix';
                break;
            default:
                message = `${length} fixes`;
        }
        return `${message} ${optional ? 'possible' : 'needed'}`;
    }
    // eslint-disable-next-line require-await
    async reportSuccess(length, lengthOptional) {
        if (length === 0 && lengthOptional === 0) {
            logger_1.default.info('Everything looks good, bye!');
            logger_1.default.info('');
            return true;
        }
        else {
            return false;
        }
    }
}
exports.Doctor = Doctor;
/**
 * @typedef DoctorOpts
 * @property {boolean?} autofix
 */
//# sourceMappingURL=doctor.js.map