"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetLog = exports.getNpmPackageInfo = exports.resolveExecutablePath = exports.configureBinaryLog = exports.inquirer = exports.nokOptional = exports.okOptional = exports.nok = exports.ok = void 0;
const bluebird_1 = __importDefault(require("bluebird"));
const inquirer_1 = __importDefault(require("inquirer"));
const logger_1 = __importDefault(require("../lib/logger"));
const support_1 = require("@appium/support");
const teen_process_1 = require("teen_process");
const lodash_1 = require("lodash");
/**
 * @param {string} message
 * @returns {UtilsResult}
 */
function ok(message) {
    return { ok: true, optional: false, message };
}
exports.ok = ok;
/**
 * @param {string} message
 * @returns {UtilsResult}
 */
function nok(message) {
    return { ok: false, optional: false, message };
}
exports.nok = nok;
/**
 * @param {string} message
 * @returns {UtilsResult}
 */
function okOptional(message) {
    return { ok: true, optional: true, message };
}
exports.okOptional = okOptional;
/**
 * @param {string} message
 * @returns {UtilsResult}
 */
function nokOptional(message) {
    return { ok: false, optional: true, message };
}
exports.nokOptional = nokOptional;
const inquirer = {
    prompt: bluebird_1.default.promisify(function (question, cb) {
        // eslint-disable-line promise/prefer-await-to-callbacks
        inquirer_1.default.prompt(question, function (resp) {
            cb(null, resp);
        }); // eslint-disable-line promise/prefer-await-to-callbacks
    }),
};
exports.inquirer = inquirer;
let actualLog;
function configureBinaryLog(opts) {
    actualLog = logger_1.default.unwrap().log;
    logger_1.default.unwrap().log = function (level, prefix, msg) {
        let l = this.levels[level];
        if (l < this.levels[this.level])
            return; // eslint-disable-line curly
        actualLog(level, prefix, msg);
        if ((0, lodash_1.isFunction)(opts.onLogMessage)) {
            opts.onLogMessage(level, prefix, msg);
        }
    };
    logger_1.default.level = opts.debug ? 'debug' : 'info';
}
exports.configureBinaryLog = configureBinaryLog;
/**
 * If {@link configureBinaryLog} was called, this will restore the original `log` function.
 */
function resetLog() {
    if (actualLog) {
        logger_1.default.unwrap().log = actualLog;
    }
}
exports.resetLog = resetLog;
/**
 * Return an executable path of cmd
 *
 * @param {string} cmd Standard output by command
 * @return {?string} The full path of cmd. `null` if the cmd is not found.
 */
async function resolveExecutablePath(cmd) {
    let executablePath;
    try {
        executablePath = await support_1.fs.which(cmd);
        if (executablePath && (await support_1.fs.exists(executablePath))) {
            return executablePath;
        }
    }
    catch (err) {
        if (/not found/gi.test(err.message)) {
            logger_1.default.debug(err);
        }
        else {
            logger_1.default.warn(err);
        }
    }
    logger_1.default.debug(`No executable path of '${cmd}'.`);
    if (executablePath) {
        logger_1.default.debug(`Does '${executablePath}' exist?`);
    }
    return null;
}
exports.resolveExecutablePath = resolveExecutablePath;
/**
 * @typedef NpmPackageInfo
 * @property {string} version - version
 * @property {string} path - A path to npm root
 */
/**
 * Returns the path and version of given package name
 * @param {string} packageName A package name to get path and version data
 * @return {?NpmPackageInfo}
 */
async function getNpmPackageInfo(packageName) {
    const npmPath = await resolveExecutablePath(`npm${support_1.system.isWindows() ? `.cmd` : ''}`);
    if (!npmPath) {
        return nokOptional(`'npm' binary not found in PATH: ${process.env.PATH}`);
    }
    let pJson = {};
    try {
        const { stdout } = await (0, teen_process_1.exec)(npmPath, ['list', '-g', '-l', '-j', packageName]);
        pJson = JSON.parse(stdout);
    }
    catch (err) {
        logger_1.default.debug(err);
        return null;
    }
    if (pJson.dependencies && pJson.dependencies[packageName]) {
        return { version: pJson.dependencies[packageName].version, path: pJson.path };
    }
    return null;
}
exports.getNpmPackageInfo = getNpmPackageInfo;
/**
 * @typedef UtilsResult
 * @property {boolean} ok
 * @property {boolean} optional
 * @property {string} message
 */
//# sourceMappingURL=utils.js.map